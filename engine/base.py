
import math


class CalculatorParameterException(Exception):
    pass


class LaunchCalculator(object):

    #   ---------------------------------------------------------------------------------------------------------
    #   NOTE:   ALL values are in standard units (kilometers, meters, etc)
    #   ---------------------------------------------------------------------------------------------------------

    EARTH_MEAN_RADIUS = 6371000     # m
    GRAVITY_SEA_LEVEL = 9.80665     # m/s^2
    AIR_DENSITY_SEA_LEVEL = 1.223   # kg/m^3
    UNIVERSAL_GAS_CONSTANT = 286.9  # J/kg K

    def __init__(self, *args, **kwargs):

        # KWARGS:
        #   thrust (N)      : Thrust in newtons generated by the rocket
        #   weight (Kg)     : Weight of the entire platform in kilograms
        #   mass (Kg)       : Mass of the rocket (If only weight given, will calculate based on gravity at sea level)
        #   area (m^2)      : Cross sectional area of the largest part of the rocket (usually a circle)
        #   initial_y (m)   : Initial altitude of rocket when launched (sea level is 0m)
        #   burn_time (s)   : Time that the rocket's engine is burning / expelling exhaust and producing thrust
        #   drag_coeff      : The drag coefficient for the rocket / object. Common Cd for a rocket is 0.75

        self.weight = None
        self.mass = None
        self.initial_altitude = 0.0

        try:
            self.thrust = float(kwargs.get('thrust'))
            self.area = float(kwargs.get('area'))
            self.burn_time = float(kwargs.get('burn_time'))
            self.drag_coefficient = float(kwargs.get('drag_coefficient'))
        except Exception as e:
            raise CalculatorParameterException(e.message)

        if 'initial_altitude' in kwargs:
            self.initial_altitude = float(kwargs.get('initial_altitude'))

        if 'mass' in kwargs:
            self.mass = float(kwargs.get('mass'))

        elif 'weight' in kwargs:
            self.mass = float(kwargs.get('weight')) / self.gravity_at_altitude(self.initial_altitude)

        else:
            raise CalculatorParameterException('Either mass or weight has to be specified in parameters.')

    def gravity_at_altitude(self, height):
        """
        Calculates the acceleration due to gravity at the given height.
        NOTE: This calculation assumes that the earth is a perfect sphere (which it is not)
        :param height: in meters
        :return:
        """
        new_height_square = math.pow(self.EARTH_MEAN_RADIUS / (self.EARTH_MEAN_RADIUS + float(height)), 2)
        gravity = self.GRAVITY_SEA_LEVEL * new_height_square
        return gravity

    def lift_at_air_density(self, air_density, speed, wing_area, lift_coefficient):
        """
        The Lift Equation.
        Calculates the amount of lift required for any flying object in a given air density (Relative to altitude).
        :param air_density: at the given altitude / in the given environment (kg/m^3)
        :param speed: of the aircraft (m/s)
        :param wing_area: Surface area of the wing of the aircraft (m^2)
        :param lift_coefficient: of the aircraft ()
        :return:
        """
        speed2 = math.pow(speed, 2)
        required_lift = float(0.5 * air_density * speed2 * wing_area * lift_coefficient)
        return required_lift

    def calculate_air_density(self, elevation):
        """
        Estimate the air density at the given altitude (kg/m^3) (mass per metre cubed (volume))
        :param elevation: m
        :return:
        """

        p0 = 101325.0
        T0 = 288.15
        L = 0.0065
        R = 8.31447
        M = 0.0289644
        g = self.gravity_at_altitude(elevation)

        temp_at_altitude = 288.15 - float(0.0065 * elevation)
        exponent = float(g * M) / float(R * L)
        internal = 1 - ((L*float(elevation))/T0)
        pressure_at_altitude = p0 * math.pow(float(internal), exponent)
        density = float(pressure_at_altitude * 0.0289644) / float(8.31447 * temp_at_altitude)

        return density

    def calculate_v(self, x, t, q):
        v0 = float(1 - math.pow(math.e, -x * t))
        v1 = float(1 + math.pow(math.e, -x * t))
        v = q * (v0 / v1)
        return v

    def calculate_x(self, k, q, m):
        x = float((2 * k * q) / m)
        return x

    def calculate_q(self, T, m, g, k):
        q = float(math.sqrt((T - (m * g)) / k))
        return q

    def calculate_k(self, air_density, drag_coefficient, area):
        """
        Calculates all of the wind resistance factors (the K coefficient)
        K = (0.5) * (air density) * (drag coefficient) * (area)

        :param air_density:
        :param drag_coefficient:
        :param area: cross sectional area of the larges part of the rocket
        :return:
        """

        k = float(0.5 * air_density * drag_coefficient * area)
        return k

    def altitude_at_burnout(self, launch_elevation):

        air_density = self.calculate_air_density(launch_elevation)

        T = float(self.thrust)
        m = float(self.mass)
        g = self.gravity_at_altitude(launch_elevation)
        k = self.calculate_k(air_density, self.drag_coefficient, self.area)
        t = float(self.burn_time)

        q = self.calculate_q(T, m, g, k)
        x = self.calculate_x(k, q, m)
        v = self.calculate_v(x, t, q)

        # Thrust, mass, speed variable
        tms = (T - (m * g) - (k * math.pow(v, 2))) / (T - (m * g))

        mk_coefficient = float(-m / (2 * k))
        burnout_altitude = mk_coefficient * math.log(tms)

        # Return the combined initial launch altitude and the burnout altitude
        return burnout_altitude + launch_elevation

    def calculate_coasting_distance(self, current_altitude):

        air_density = self.calculate_air_density(current_altitude)

        T = self.thrust
        g = self.gravity_at_altitude(current_altitude)
        m = float(self.mass)
        k = self.calculate_k(air_density, self.drag_coefficient, self.area)
        t = self.burn_time

        q = self.calculate_q(T, m, g, k)
        x = self.calculate_x(k, q, m)
        v = self.calculate_v(x, t, q)

        coefficient = float(m / (2 * k))
        internal = float(m * g + k * math.pow(v, 2)) / float(m * g)

        coasting_distance = coefficient * math.log(internal)
        return coasting_distance


if __name__ == "__main__":

    params = {
        'drag_coefficient' : 0.75,
        'thrust': 17792.8864,
        'burn_time': 8.0,
        'mass': 14.80118,
        'area': 0.129717,
        'initial_altitude': 6095.9998,
    }

    calculator = LaunchCalculator(**params)

    # Launching at 20,000 ft, of 6095.9998 meters
    burnout_altitude = calculator.altitude_at_burnout(6095.9998)
    coasting_distance = calculator.calculate_coasting_distance(burnout_altitude)

    print "Burn-out Altitude: " + str(burnout_altitude) + " meters"
    print "Coasting Distance: " + str(coasting_distance) + " meters"

    print "Final Launch Altitude: " + str(burnout_altitude + coasting_distance) + " meters"







